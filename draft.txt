NÃ£o estou tento retorno do token, 
envio o body na requisiÃ§Ã£o:
{
	"cpf":"12345678901",
	"password":"hashedpassword1"
}

E nÃ£o gerou o token, vou enviar os arquivos e cÃ³digos para verificar:

Estrutura nome da pasta e cÃ³digo abaixo:
.env
./config/auth
./config/env.js
./config/db.js

./contoller/AuthController.js
./controller/ShiftController.js
.controller.UserController.js

./middlewares/authMiddlewares.js
./middlewares/errorHandles.js

./models/Shift.js
./models/User.js

./routes/authRoutes.js
./routes/shiftRoutes.js
./userRoutes.js

./services/AuthServices.js
./services/NotificationServices.js

./utils/helpers.js

./app.js
./server.js

Com esta estrutura quero Uma API, que recebe de um app mobile, senha e email, verifica se esta correto e envia o token para acesso a aplicaÃ§Ã£o.
Desta forma a aplicaÃ§Ã£o acessa as rotas com o token e leva os resultados que esta no banco de dados, com o que for solicitado em cada rota. 
desconsidere o que estiver na hota home, ou com este sufixo, pois Ã© sÃ³ um teste e nÃ£o faz parte ada aplicaÃ§Ã£o principal ainda. 

Agora vou enviar cada arquivo dessa estrutura que enviei. 

___

Arquivo: .env

# EndereÃ§o da API
PORT=3000        # Porta do servidor

# Acesso ao Banco de Dados cubraqui
DB_HOST=db       # Nome do serviÃ§o Docker do banco
DB_PORT=3306     # Porta padrÃ£o interna do MySQL
DB_USER=root     # UsuÃ¡rio MySQL
DB_PASSWORD=root # Senha MySQL
DB_NAME=cubraqui # Nome do banco
DB_DIALECT=mysql # Dialeto para Sequelize

# Token da AplicaÃ§Ã£o
APP_TOKEN_SECRET_KEY=tokenDoApp

# ConfiguraÃ§Ãµes JWT
JWT_SECRET=defaultSecretKey
JWT_EXPIRES_IN=1h

___

Arquivo: ./config/auth

const { JWT_SECRET, JWT_EXPIRES_IN, APP_TOKEN_SECRET_KEY } = require('./env');

module.exports = {
  jwtSecret: JWT_SECRET || 'defaultSecretKey',
  jwtExpiresIn: JWT_EXPIRES_IN || '1h',
  appTokenSecretKey: APP_TOKEN_SECRET_KEY || 'defaultAppToken',
};

___

Arquivo: ./config/env.js

require('dotenv').config();

module.exports = {
  // ConfiguraÃ§Ãµes do Banco de Dados
  DB_NAME: process.env.DB_NAME,
  DB_USER: process.env.DB_USER,
  DB_PASSWORD: process.env.DB_PASSWORD,
  DB_HOST: process.env.DB_HOST,
  DB_PORT: process.env.DB_PORT,
  DB_DIALECT: process.env.DB_DIALECT || 'mysql',

  // ConfiguraÃ§Ãµes de AutenticaÃ§Ã£o JWT
  JWT_SECRET: process.env.JWT_SECRET || 'defaultSecretKey',
  JWT_EXPIRES_IN: process.env.JWT_EXPIRES_IN || '1h',

  // Token da AplicaÃ§Ã£o
  APP_TOKEN_SECRET_KEY: process.env.APP_TOKEN_SECRET_KEY || 'defaultAppToken',

  // Outras ConfiguraÃ§Ãµes
  PORT: process.env.PORT || 3000,
};

___

Arquivo: ./config/db.js

const { Sequelize } = require('sequelize');
const { DB_NAME, DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, DB_DIALECT } = require('./env'); // Importa do env.js

const sequelize = new Sequelize(
  DB_NAME,   // Nome do banco
  DB_USER,   // UsuÃ¡rio
  DB_PASSWORD, // Senha
  {
    host: DB_HOST, // Host do banco de dados
    port: DB_PORT, // Porta do banco de dados
    dialect: DB_DIALECT, // Tipo do banco de dados
  }
);

module.exports = sequelize;

___


Arquivo: ./contoller/AuthController.js

const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');
const { JWT_SECRET, JWT_EXPIRES_IN, APP_TOKEN_SECRET_KEY } = require('../config/env');
const User = require('../models/User');

module.exports = {
  async login(req, res) {
    const { cpf, password } = req.body;

    try {
      const user = await User.findOne({ where: { cpf } });

      if (!user) {
        return res.status(404).json({ message: 'UsuÃ¡rio nÃ£o encontrado' });
      }

      const passwordMatch = await bcrypt.compare(password, user.password);

      if (!passwordMatch) {
        return res.status(401).json({ message: 'Senha incorreta' });
      }

      // Gera o token JWT usando a chave JWT
      const token = jwt.sign(
        { id: user.id, cpf: user.cpf },
        JWT_SECRET,
        { expiresIn: JWT_EXPIRES_IN }
      );

      // Gera um token adicional da aplicaÃ§Ã£o, se necessÃ¡rio
      const appToken = jwt.sign(
        { app: 'cubraqui' },
        APP_TOKEN_SECRET_KEY,
        { expiresIn: '1h' }
      );

      return res.json({
        message: 'Login bem-sucedido',
        token,
        appToken,
      });
    } catch (error) {
      console.error(error);
      return res.status(500).json({ message: 'Erro no servidor' });
    }
  }
};


___

Arquivo: ./controller/ShiftController.js

module.exports = {
    async getAllShifts(req, res) {
      res.json({ message: 'Listando todos os turnos' });
    }
  };
  
___

Arquivo: .controller.UserController.js

const User = require('../models/User');

module.exports = {
  async getAllUsers(req, res) {
    const users = await User.findAll();
    return res.json(users);
  }
};

___


Arquivo: ./middlewares/authMiddlewares.js
module.exports = (req, res, next) => {
    const token = req.headers.authorization;
    if (!token) return res.status(401).json({ error: 'Token is required' });
    next();
  };
  
  ___

  
Arquivo: ./middlewares/errorHandles.js

module.exports = (err, req, res, next) => {
    console.error(err.stack);
    res.status(500).send('Something went wrong!');
  };
  
  ___
Arquivo: ./models/Shift.js

const { DataTypes } = require('sequelize');
const db = require('../config/db');

const Shift = db.define('Shift', {
  shiftTime: {
    type: DataTypes.STRING,
    allowNull: false,
  },
  location: {
    type: DataTypes.STRING,
    allowNull: false,
  },
});

module.exports = Shift;

___

Arquivo: ./models/User.js

const { DataTypes } = require('sequelize');
const db = require('../config/db');

const User = db.define('User', {
  id: {
    type: DataTypes.INTEGER,
    autoIncrement: true,
    primaryKey: true, // Chave primÃ¡ria para relaÃ§Ãµes e performance
  },
  cpf: {
    type: DataTypes.STRING(11),
    unique: true,
    allowNull: false,
    validate: {
      isNumeric: true,
      len: [11, 11],
    },
  },
  fullName: {
    type: DataTypes.STRING(100),
    allowNull: false,
  },
  email: {
    type: DataTypes.STRING(100),
    allowNull: false,
    unique: true,
    validate: {
      isEmail: true,
    },
  },
  password: {
    type: DataTypes.STRING(255),
    allowNull: false,
  },
  registrationDate: {
    type: DataTypes.DATE,
    defaultValue: DataTypes.NOW,
  },
}, {
  tableName: 'User', // Usa o nome exato da tabela criada no SQL
  timestamps: false, // NÃ£o cria createdAt e updatedAt
  freezeTableName: true, // Evita pluralizaÃ§Ã£o do Sequelize
});

module.exports = User;

___

Arquivo: ./routes/authRoutes.js

const express = require('express');
const AuthController = require('../controllers/AuthController');

const router = express.Router();

router.post('/login', AuthController.login);

module.exports = router;

___

Arquivo: ./routes/shiftRoutes.js

const express = require('express');
const ShiftController = require('../controllers/ShiftController');

const router = express.Router();

router.get('/shifts', ShiftController.getAllShifts);

module.exports = router;

___

Arquivo: ./userRoutes.js

const express = require('express');
const UserController = require('../controllers/UserController');

const router = express.Router();

router.get('/users', UserController.getAllUsers);

module.exports = router;

___


Arquivo: ./services/AuthServices.js

module.exports = {
    authenticateUser(email, password) {
      return email === 'admin@example.com' && password === 'admin123';
    }
  };
  
___

Arquivo: ./services/NotificationServices.js

module.exports = {
    sendNotification(user, message) {
      console.log(`Enviando notificaÃ§Ã£o para ${user}: ${message}`);
    }
  };
  
  
Arquivo: ./utils/helpers.js

module.exports = {
    formatResponse(data) {
      return { success: true, data };
    }
  };
  ___

Arquivo: ./app.js

const express = require('express');
const userRoutes = require('./routes/userRoutes');
const shiftRoutes = require('./routes/shiftRoutes');
const authRoutes = require('./routes/authRoutes');
const errorHandler = require('./middlewares/errorHandler');
const homeRoutes = require('./routes/homeRoutes'); // Nome correto

const app = express();

// Middleware para tratar JSON
app.use(express.json());

// Rotas
app.use('/', homeRoutes);
app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes);
app.use('/api/shifts', shiftRoutes);

// Middleware de tratamento de erros
app.use(errorHandler);

module.exports = app;

___

Arquivo: ./server.js

require('dotenv').config(); // Carregar variÃ¡veis de ambiente do .env
const app = require('./app');
const db = require('./config/db'); // Importa a configuraÃ§Ã£o do banco de dados
const { PORT } = require('./config/env');

// Conectar ao banco de dados e iniciar o servidor
db.authenticate()
  .then(() => console.log('âœ… Conectado ao banco de dados MySQL!'))
  .catch(err => console.error('âŒ Erro ao conectar ao MySQL:', err));

db.sync() // Sincroniza o banco (cria as tabelas)
  .then(() => {
    // Inicia o servidor na porta definida
    app.listen(PORT, () => {
      console.log(`ğŸš€ Servidor rodando na porta ${PORT}`);
    });
  })
  .catch(err => console.error('âŒ Erro ao sincronizar banco:', err));
